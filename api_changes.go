
/*
 * Proff API
 *
 * You need a valid token to access Proff API. Contact sales for more information. Token header: Authorization : Token [YOUR_TOKEN]
 *
 * API version: 1.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package proff

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type ChangesApiService service
/*
ChangesApiService Changed companies and business units
Changes to publicly registered companies are normally updated once a day.&lt;br /&gt;                Companies are considered changed when they are removed from the RegisterCompany resource.  Companies are removed from the RegisterCompany resource after having been marked deleted for over 12 months.  New established companies are considered to be a change and will be included.  Deletion of companies is considered to be a change and will be included.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param country The country to search within. Must be a two letter uppercase ISO 3166-1-alpha-2 country code.  Possible values: \&quot;NO\&quot;
 * @param optional nil or *ChangesApiApiChangesRegisterCountryGetOpts - Optional Parameters:
     * @param "ScrollId" (optional.String) -  Specify a scroll Id to advance to the next batch of results.  If specified any other parameter is ignored.                Generally
     * @param "Types" (optional.Interface of []string) -  Type of changes returned in the search result.  Choose one or more of the following values:    ADDED: gets new documents    REMOVED: gets removed documents    MUTATED: gets changed documents    If MUTATED is specified all fields are considered.  See fields for details on overriding considered fields.                By default all added, removed and changed documents are returned.
     * @param "WithPatch" (optional.Bool) -  The JSONPatch should be returned with each ChangedDoc element
     * @param "Since" (optional.String) -  To include ChangedDocs older than 1 day set this date. We keep a history of 30 days of changes.  If you have missed changes older 30 days, you should fetch the original document again.     Format: yyyy-MM-dd
     * @param "Fields" (optional.Interface of []string) -  Which fields to look for changes in. Only applies for MUTATED documents.    If MUTATED documents are requested, the paths that are searched for changes can be overridden by specifying this parameter one or more times.   E.g. specify fields&#x3D;/name&amp;fields&#x3D;/phoneNumbers if you are only interested in changes to name or phoneNumbers.                The paths refers to fields in the RegisterCompany schema.  They are used as prefixes, so /personRoles includes any change to any element in the array.    If you only specify this parameter, all ADDED, REMOVED and MUTATED (where this parameter matches) documents are returned.    If you want to exclude ADDED and REMOVED documents you have to specify the types parameter (with the MUTATED value).
@return ChangesResult
*/

type ChangesApiApiChangesRegisterCountryGetOpts struct {
    ScrollId optional.String
    Types optional.Interface
    WithPatch optional.Bool
    Since optional.String
    Fields optional.Interface
}

func (a *ChangesApiService) ApiChangesRegisterCountryGet(ctx context.Context, country string, localVarOptionals *ChangesApiApiChangesRegisterCountryGetOpts) (ChangesResult, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ChangesResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/changes/register/{country}"
	localVarPath = strings.Replace(localVarPath, "{"+"country"+"}", fmt.Sprintf("%v", country), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ScrollId.IsSet() {
		localVarQueryParams.Add("scrollId", parameterToString(localVarOptionals.ScrollId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Types.IsSet() {
		localVarQueryParams.Add("types", parameterToString(localVarOptionals.Types.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.WithPatch.IsSet() {
		localVarQueryParams.Add("withPatch", parameterToString(localVarOptionals.WithPatch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Since.IsSet() {
		localVarQueryParams.Add("since", parameterToString(localVarOptionals.Since.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ChangesResult
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
