
/*
 * Proff API
 *
 * You need a valid token to access Proff API. Contact sales for more information. Token header: Authorization : Token [YOUR_TOKEN]
 *
 * API version: 1.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package proff

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type ProCompanyApiService service
/*
ProCompanyApiService A list of Eniro Pro company resources.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param country Country to search within. Must be a two letter uppercase ISO 3166-1-alpha-2 country code.              Possible values:              &lt;value&gt;NO&lt;/value&gt;,              &lt;value&gt;DK&lt;/value&gt;,              &lt;value&gt;SE&lt;/value&gt;
 * @param optional nil or *ProCompanyApiApiCompaniesEniroproCountryGetOpts - Optional Parameters:
     * @param "Name" (optional.String) -  Free text search on company name. Case insensitive. Mutually exclusive with the &#x27;industry&#x27; parameter.
     * @param "IndustryCode" (optional.String) -  Search on industry code.
     * @param "Industry" (optional.String) -  Free text search on company industry. Case insensitive. Mutually exclusive with the &#x27;name&#x27; parameter.
     * @param "Sort" (optional.String) -  How the list should be sorted. Default is companyRank.
     * @param "MapBoundingBox" (optional.String) -  Comma-separated list containing 2 pairs of coordinates (long, lat) for a map bounding box. First pair is lower-left corner, second pair is upper-right corner. Sequence: Western longitude, southern latitude, eastern longitude, northern latitude E.g.: 10.7417397,59.9152922,10.8417397,59.9952922
     * @param "Filter" (optional.String) -  Custom filter
     * @param "Expand" (optional.Bool) -  Should the registerListing be expanded in the returned documents
     * @param "NoOfNearbyPages" (optional.Int32) -  Preferred number of pagination uris.
     * @param "PageSize" (optional.Int32) -  Preferred number of resources returned for a particular query - defaults to 10.
     * @param "PageNumber" (optional.Int32) -  Requested page number - defaults to 1.
     * @param "FilterPageSize" (optional.Int32) -  Overrides page size parameter for embedded filter links in the response.
     * @param "SortPageSize" (optional.Int32) -  Overrides page size parameter for embedded sort links in the response.
@return EniroProCompanyList
*/

type ProCompanyApiApiCompaniesEniroproCountryGetOpts struct {
    Name optional.String
    IndustryCode optional.String
    Industry optional.String
    Sort optional.String
    MapBoundingBox optional.String
    Filter optional.String
    Expand optional.Bool
    NoOfNearbyPages optional.Int32
    PageSize optional.Int32
    PageNumber optional.Int32
    FilterPageSize optional.Int32
    SortPageSize optional.Int32
}

func (a *ProCompanyApiService) ApiCompaniesEniroproCountryGet(ctx context.Context, country string, localVarOptionals *ProCompanyApiApiCompaniesEniroproCountryGetOpts) (EniroProCompanyList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue EniroProCompanyList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/companies/eniropro/{country}"
	localVarPath = strings.Replace(localVarPath, "{"+"country"+"}", fmt.Sprintf("%v", country), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IndustryCode.IsSet() {
		localVarQueryParams.Add("industryCode", parameterToString(localVarOptionals.IndustryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Industry.IsSet() {
		localVarQueryParams.Add("industry", parameterToString(localVarOptionals.Industry.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MapBoundingBox.IsSet() {
		localVarQueryParams.Add("mapBoundingBox", parameterToString(localVarOptionals.MapBoundingBox.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Expand.IsSet() {
		localVarQueryParams.Add("expand", parameterToString(localVarOptionals.Expand.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NoOfNearbyPages.IsSet() {
		localVarQueryParams.Add("noOfNearbyPages", parameterToString(localVarOptionals.NoOfNearbyPages.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageNumber.IsSet() {
		localVarQueryParams.Add("pageNumber", parameterToString(localVarOptionals.PageNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilterPageSize.IsSet() {
		localVarQueryParams.Add("filterPageSize", parameterToString(localVarOptionals.FilterPageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SortPageSize.IsSet() {
		localVarQueryParams.Add("sortPageSize", parameterToString(localVarOptionals.SortPageSize.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v EniroProCompanyList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ProCompanyApiService Lookup a specific Eniro Pro company resource.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param country Country to search within. Must be a two letter uppercase ISO 3166-1-alpha-2 country code.               Possible values:                                  &lt;value&gt;NO&lt;/value&gt;,                                  &lt;value&gt;DK&lt;/value&gt;,                                  &lt;value&gt;SE&lt;/value&gt;
 * @param id The unique identifier for the entity.
@return EniroProCompanyDetails
*/
func (a *ProCompanyApiService) ApiCompaniesEniroproCountryIdGet(ctx context.Context, country string, id string) (EniroProCompanyDetails, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue EniroProCompanyDetails
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/companies/eniropro/{country}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"country"+"}", fmt.Sprintf("%v", country), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v EniroProCompanyDetails
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ProCompanyApiService Root location of a location tree with country as root element.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param country Country to search within. Must be a two letter uppercase ISO 3166-1-alpha-2 country code.               Possible values:                                  &lt;value&gt;NO&lt;/value&gt;,                                  &lt;value&gt;DK&lt;/value&gt;,                                  &lt;value&gt;SE&lt;/value&gt;
@return EniroProLocation
*/
func (a *ProCompanyApiService) ApiCompaniesEniroproLocationsCountryGet(ctx context.Context, country string) (EniroProLocation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue EniroProLocation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/companies/eniropro/locations/{country}"
	localVarPath = strings.Replace(localVarPath, "{"+"country"+"}", fmt.Sprintf("%v", country), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v EniroProLocation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
