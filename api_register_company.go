
/*
 * Proff API
 *
 * You need a valid token to access Proff API. Contact sales for more information. Token header: Authorization : Token [YOUR_TOKEN]
 *
 * API version: 1.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package proff

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type RegisterCompanyApiService service
/*
RegisterCompanyApiService List of register business category entities
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param country Country to search within. Must be a two letter uppercase ISO 3166-1-alpha-2 country code.  Possible values: NO,SE,DK,FI
@return []RegisterBusinessCategory
*/
func (a *RegisterCompanyApiService) ApiCompaniesRegisterBusinesscategoriesCountryGet(ctx context.Context, country string) ([]RegisterBusinessCategory, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []RegisterBusinessCategory
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/companies/register/businesscategories/{country}"
	localVarPath = strings.Replace(localVarPath, "{"+"country"+"}", fmt.Sprintf("%v", country), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []RegisterBusinessCategory
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
RegisterCompanyApiService Get all official company types.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param country Country to search within. Must be a two letter uppercase ISO 3166-1-alpha-2 country code.  Possible values: NO,SE,DK,FI
@return []RegisterCompanyType
*/
func (a *RegisterCompanyApiService) ApiCompaniesRegisterCompanytypesCountryGet(ctx context.Context, country string) ([]RegisterCompanyType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []RegisterCompanyType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/companies/register/companytypes/{country}"
	localVarPath = strings.Replace(localVarPath, "{"+"country"+"}", fmt.Sprintf("%v", country), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []RegisterCompanyType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
RegisterCompanyApiService List of publicly registered companies.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param country
 * @param optional nil or *RegisterCompanyApiApiCompaniesRegisterCountryGetOpts - Optional Parameters:
     * @param "Sort" (optional.String) -  How the list should be sorted. If not specified, a default sorting is used.  Table of default sorting.  query parameters  Default sorting  profitFrom, profitTo profitDesc  revenueFrom, revenueTo revenueDesc  establishedYearFrom, establishedYearTo establishedYearAsc  numEmployeesFrom, numEmployeesTo, numEmployeesDesc  companyType, profitDesc  location, profitDesc  query relevance                 When mixing query parameters with different defaults, the default sorting is always the first one  in the table that matches a query parameter.    Possible values:  numEmployeesAsc, numEmployeesDesc, revenueAsc, revenueDesc, establishedYearAsc, establishedYearDesc,  companyNameDesc, naceIndustryName, companyTypeNameDesc, profitAsc, profitDesc, relevance, postNumber
     * @param "IndustryCode" (optional.String) -  Get industry code
     * @param "Location" (optional.String) -  Filter by a location.  Examples (description in parenthesis is not a part of the value):  \&quot;Viken\&quot; (county), \&quot;Drammen\&quot; (municipality), \&quot;Ã˜stlandet\&quot; (country part)
     * @param "Query" (optional.String) -  Free text query. Case insensitive. Required if none of the other parameters are used. If  this is the only parameter set it is considered to be a \&quot;simple search\&quot; which affects which sorting you can use.
     * @param "NumEmployeesFrom" (optional.String) -  Number of employees, from
     * @param "NumEmployeesTo" (optional.String) -  Highest number of employees companies in the list should have.
     * @param "RevenueFrom" (optional.String) -  Lowest revenue companies in the list should have.
     * @param "RevenueTo" (optional.String) -  Highest revenue companies in the list should have.
     * @param "ProfitFrom" (optional.String) -  Lowest profit companies in the list should have.
     * @param "ProfitTo" (optional.String) -  Highest profit companies in the list should have.
     * @param "EstablishedYearFrom" (optional.String) -  Earliest year the companies in the list should have been established.
     * @param "EstablishedYearTo" (optional.String) -  Most recent year the companies in the list should have been established.
     * @param "CompanyType" (optional.Interface of []string) -  Array of company types.  Some examples of Norwegian codes: \&quot;AS\&quot;, \&quot;ANS\&quot;, \&quot;EP\&quot; and \&quot;NUF\&quot;.
     * @param "Industry" (optional.String) -  Get industries
     * @param "FoundationDateFrom" (optional.String) -  Foundation date from - dd.MM.yyyy format
     * @param "FoundationDateTo" (optional.String) -  Foundation date to - dd.MM.yyyy format
     * @param "LiquidationDateFrom" (optional.String) -  Liquidation from - dd.MM.yyyy format
     * @param "LiquidationDateTo" (optional.String) -  Liquidation date to - dd.MM.yyyy format
     * @param "Filter" (optional.String) -  Filter. E.g.: status:AKTIVT
     * @param "NoOfNearbyPages" (optional.Int32) -  Preferred number of pagination uris.
     * @param "PageSize" (optional.Int32) -  Preferred number of resources returned for a particular query - defaults to 10.
     * @param "PageNumber" (optional.Int32) -  Requested page number - defaults to 1.
     * @param "FilterPageSize" (optional.Int32) -  Overrides page size parameter for embedded filter links in the response.
     * @param "SortPageSize" (optional.Int32) -  Overrides page size parameter for embedded sort links in the response.
@return RegisterCompanyList
*/

type RegisterCompanyApiApiCompaniesRegisterCountryGetOpts struct {
    Sort optional.String
    IndustryCode optional.String
    Location optional.String
    Query optional.String
    NumEmployeesFrom optional.String
    NumEmployeesTo optional.String
    RevenueFrom optional.String
    RevenueTo optional.String
    ProfitFrom optional.String
    ProfitTo optional.String
    EstablishedYearFrom optional.String
    EstablishedYearTo optional.String
    CompanyType optional.Interface
    Industry optional.String
    FoundationDateFrom optional.String
    FoundationDateTo optional.String
    LiquidationDateFrom optional.String
    LiquidationDateTo optional.String
    Filter optional.String
    NoOfNearbyPages optional.Int32
    PageSize optional.Int32
    PageNumber optional.Int32
    FilterPageSize optional.Int32
    SortPageSize optional.Int32
}

func (a *RegisterCompanyApiService) ApiCompaniesRegisterCountryGet(ctx context.Context, country string, localVarOptionals *RegisterCompanyApiApiCompaniesRegisterCountryGetOpts) (RegisterCompanyList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RegisterCompanyList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/companies/register/{country}"
	localVarPath = strings.Replace(localVarPath, "{"+"country"+"}", fmt.Sprintf("%v", country), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IndustryCode.IsSet() {
		localVarQueryParams.Add("industryCode", parameterToString(localVarOptionals.IndustryCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Query.IsSet() {
		localVarQueryParams.Add("query", parameterToString(localVarOptionals.Query.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NumEmployeesFrom.IsSet() {
		localVarQueryParams.Add("numEmployeesFrom", parameterToString(localVarOptionals.NumEmployeesFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NumEmployeesTo.IsSet() {
		localVarQueryParams.Add("numEmployeesTo", parameterToString(localVarOptionals.NumEmployeesTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RevenueFrom.IsSet() {
		localVarQueryParams.Add("revenueFrom", parameterToString(localVarOptionals.RevenueFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RevenueTo.IsSet() {
		localVarQueryParams.Add("revenueTo", parameterToString(localVarOptionals.RevenueTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProfitFrom.IsSet() {
		localVarQueryParams.Add("profitFrom", parameterToString(localVarOptionals.ProfitFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProfitTo.IsSet() {
		localVarQueryParams.Add("profitTo", parameterToString(localVarOptionals.ProfitTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EstablishedYearFrom.IsSet() {
		localVarQueryParams.Add("establishedYearFrom", parameterToString(localVarOptionals.EstablishedYearFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EstablishedYearTo.IsSet() {
		localVarQueryParams.Add("establishedYearTo", parameterToString(localVarOptionals.EstablishedYearTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CompanyType.IsSet() {
		localVarQueryParams.Add("companyType", parameterToString(localVarOptionals.CompanyType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Industry.IsSet() {
		localVarQueryParams.Add("industry", parameterToString(localVarOptionals.Industry.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FoundationDateFrom.IsSet() {
		localVarQueryParams.Add("foundationDateFrom", parameterToString(localVarOptionals.FoundationDateFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FoundationDateTo.IsSet() {
		localVarQueryParams.Add("foundationDateTo", parameterToString(localVarOptionals.FoundationDateTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LiquidationDateFrom.IsSet() {
		localVarQueryParams.Add("liquidationDateFrom", parameterToString(localVarOptionals.LiquidationDateFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LiquidationDateTo.IsSet() {
		localVarQueryParams.Add("liquidationDateTo", parameterToString(localVarOptionals.LiquidationDateTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NoOfNearbyPages.IsSet() {
		localVarQueryParams.Add("noOfNearbyPages", parameterToString(localVarOptionals.NoOfNearbyPages.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageNumber.IsSet() {
		localVarQueryParams.Add("pageNumber", parameterToString(localVarOptionals.PageNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilterPageSize.IsSet() {
		localVarQueryParams.Add("filterPageSize", parameterToString(localVarOptionals.FilterPageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SortPageSize.IsSet() {
		localVarQueryParams.Add("sortPageSize", parameterToString(localVarOptionals.SortPageSize.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RegisterCompanyList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
RegisterCompanyApiService Corporate structure look-up for a specific register company resource.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param country Country to search within. Must be a two letter uppercase ISO 3166-1-alpha-2 country code.  Possible values: NO, SE, DK
 * @param id Unique identifier for the entity.
@return CorporateStructure
*/
func (a *RegisterCompanyApiService) ApiCompaniesRegisterCountryIdCorporateStructureGet(ctx context.Context, country string, id string) (CorporateStructure, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CorporateStructure
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/companies/register/{country}/{id}/corporateStructure"
	localVarPath = strings.Replace(localVarPath, "{"+"country"+"}", fmt.Sprintf("%v", country), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CorporateStructure
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
RegisterCompanyApiService Register company resource look-up.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param country Country to search within. Must be a two letter uppercase ISO 3166-1-alpha-2 country code.  Possible values: NO,SE,DK,FI
 * @param id Unique identifier for the entity.
@return RegisterCompanyDetails
*/
func (a *RegisterCompanyApiService) ApiCompaniesRegisterCountryIdGet(ctx context.Context, country string, id string) (RegisterCompanyDetails, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RegisterCompanyDetails
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/companies/register/{country}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"country"+"}", fmt.Sprintf("%v", country), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain", "application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RegisterCompanyDetails
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
